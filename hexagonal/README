mvn archetype:generate -D groupId=dev.hugodesouzacaramez.hexagonal -D artifactId=hexagonal -D archetypeArtifactId=maven-archetype-quickstart -D interactiveMode=false


Refatorando uma aplicação de arquitetura em camadas
em uma hexagonal

Agora, temos uma ideia de como implementar uma aplicação de arquitetura em camadas. Vamos refatorar
esta aplicação que acabamos de desenvolver em uma hexagonal. Este exercício destacará as diferenças
significativas entre as duas arquiteturas.

========================
Implementando o hexágono de domínio

O hexágono de domínio contém dados e comportamentos com lógica de sistema central. Nas etapas a seguir,
veja como refatorar alguns dados e comportamentos da aplicação em camadas usando a abordagem hexagonal:

1. Ao usar a arquitetura em camadas, começamos a desenvolver o sistema implementando a camada de
dados. Vamos refatorá-lo em um hexágono de Domínio contendo apenas uma classe de entidade de domínio de Usuário:

@Getter
@Setter
@RequiredArgsConstructor
@NoArgsConstructor
public class User {
 private Long id;
 @NonNull
 private String email;
 @NonNull
 private String password;
 public User(Long id, String email, String
 password) {
 this.id = id;
 this.email = email;
 this.password = password;
 }
 /** Code omitted **/
}

A principal diferença é que essa entidade não é um ORM usado para mapear entidades de banco de dados. Essa
entidade é um POJO que contém não apenas dados, mas também comportamentos. Vamos implementar esses comportamentos.

2. Na classe de entidade Usuário , implementamos o método isEmailAlreadyUsed:

public void isEmailAlreadyUsed(Optional<User> op
 tionalUser) throws Exception {
 if(optionalUser.isPresent()) {
 throw new Exception(
 "Email address already exist");
 }
}

isEmailAlreadyUsed recebe um parâmetro Optional<User> . Se o valor estiver presente,
então lançamos uma exceção.

3. Para finalizar a implementação da classe de entidade User , criamos o login e
Métodos isPasswordValid:

public String login(Optional<User> optionalUser) {
 if (optionalUser.isPresent()) {
 var user = optionalUser.get();
 var isThePasswordValid =
 isThePasswordValid(user);
 if (isThePasswordValid) {
 return "Authenticated with success";
 } else {
 return "Invalid credentials";
 }
 } else {
  return "Invalid credentials";
  }
 }
 private boolean isThePasswordValid(User user) {
  return user.getPassword().equals(this.password);
 }

 A lógica é semelhante aos métodos que implementamos no aplicativo em camadas, mas em vez de usar
 uma classe UserDto , operamos diretamente na classe de entidade de domínio User.

 Seguindo uma abordagem DDD, empurramos a lógica da Camada de Serviço para o hexágono de
 Domínio no aplicativo hexagonal. Métodos contendo lógica de sistema central que costumavam estar na
 camada de serviço agora fazem parte da classe de entidade de domínio Usuário no hexágono de Domínio.

 A diferença significativa aqui é que o hexágono de Domínio não depende de nada. Em
 Criar uma conta e poder efetuar login são os dois casos de uso suportados pelo nosso aplicativo.
 Em contraste, na abordagem de arquitetura em camadas, a camada de serviço que contém a lógica do
 sistema central depende da camada de dados.

 =======================================
 Implementando o hexágono do aplicativo

 Implementamos a classe de entidade de domínio User no hexágono Domain contendo lógica central para
 manipular o registro e login do usuário. Precisamos definir como, de forma agnóstica, os
 comportamentos serão acionados e como os dados externos serão recuperados. Por agnóstico, quero
 dizer expressar a necessidade de dados externos sem entrar nos detalhes da tecnologia para fornecer
 tais dados. Empregamos casos de uso e portas de entrada e saída no hexágono Application:

 1. Vamos começar definindo a interface UserAccessUserCase:

 public interface UserAccessUseCase {
  String createAccount(User user) throws Exception;
  String login(User user);
 }

Criar uma conta e poder efetuar login são os dois casos de uso suportados pelo nosso aplicativo.

2. Para permitir o manuseio de dados externos, definimos a interface UserAccessOutputPort:

public interface UserAccessOutputPort {
 Optional<User> findByEmail(String email);
 void persist(User user);
}

Esta interface é apenas um POJO contendo as definições dos métodos findByEmail e persist .
UserAccessInputPort implementa a interface UserAccessUseCase . Observe que estamos
injetando UserAccessOutputPort. É por meio dessa porta de saída que a porta de entrada
manipulará dados externos. O método createAccount verifica se o e-mail já existe, confiando
na lógica fornecida pelo método isEmailAlreadyUsed do User
Na abordagem de arquitetura em camadas, tínhamos esses métodos como parte da classe de
repositório na camada de dados. Na classe de repositório, estava implícito que os dados viriam de um banco de dados.
Na abordagem hexagonal, expressamos, por meio da interface da porta de saída, que os dados
podem vir de qualquer lugar.

3. Finalizamos implementando a classe UserAccessInputPort:

@ApplicationScoped
public class UserAccessInputPort implements UserAcces
 sUseCase {
@Inject
UserAccessOutputPort userAccessOutputPort;
@Override
public String createAccount(User user) throws
Exception {
 user.isEmailAlreadyUsed
 (userAccessOutputPort.findByEmail
 (user.getEmail()));
 userAccessOutputPort.persist(user);
 return "User successfully created";
}
@Override
public String login(User user) {
 return
 user.login(
 userAccessOutputPort
 .findByEmail(user.getEmail()));
 }
}

UserAccessInputPort implementa a interface UserAccessUseCase . Observe que estamos
injetando UserAccessOutputPort. É por meio dessa porta de saída que a porta de entrada
manipulará dados externos. O método createAccount verifica se o e-mail já existe, confiando
na lógica fornecida pelo método isEmailAlreadyUsed do User classe de entidade de domínio. O método de login também depende do hexágono Domain chamando
o método de login presente na classe de entidade de domínio User.

O hexágono Application nos permitiu expressar como o sistema deve manipular dados externos em
conjunto com a lógica do sistema central do hexágono Domain. Ao contrário do que fizemos na
abordagem de arquitetura em camadas, a lógica do sistema central e a manipulação de dados externos
foram definidas sem especificar se os dados estão vindo de um banco de dados ou de outro lugar.

Essa abordagem de expressar, por meio de portas de saída, quais dados o sistema precisa sem expor
como o sistema obterá esses dados é uma diferença significativa entre a arquitetura em camadas e a hexagonal.

==========================================
Implementando o Framework hexagon

O hexágono do aplicativo orquestra dados externos com a lógica do sistema central do hexágono do domínio.
Ainda assim, precisamos fornecer uma maneira de obter esses dados externos. Na abordagem de arquitetura em
camadas, a camada de dados nos permitiu obter dados de um banco de dados, e a camada de API expôs endpoints
REST. No hexágono do Framework, usamos adaptadores de entrada para fornecer os endpoints REST e
adaptadores de saída para obter dados de um banco de dados. Vamos implementar:

1. Começamos com a classe UserAccessInputAdapter:

@Path("/user")
public class UserAccessInputAdapter {
 @Inject
 UserAccessUseCase userAccessUseCase;
 /** Code omitted **/
}

Injetamos UserAccessUseCase para acessar as operações disponíveis no hexágono Application.

2. Na classe UserAccessInputAdapter , implementamos o método register:

@POST
@Produces(MediaType.TEXT_PLAIN)
@Consumes(MediaType.APPLICATION_JSON)
@Path("/register")
public String register(UserDto userDto) throws Excep
 tion {
 return userAccessUseCase.createAccount(new
 User(userDto.email(), userDto.password()));
}

Mapeamos UserDto diretamente para a classe de entidade de domínio User . Então, passamos para o
método createAccount de UserAccessUseCase.

3. Para finalizar a implementação do UserAccessInputAdapter , criamos o método login:

@POST
@Produces(MediaType.TEXT_PLAIN)
@Consumes(MediaType.APPLICATION_JSON)
@Path("/login")
public String login(UserDto userDto) {
 return userAccessUseCase.login(new
 User(userDto.email(), userDto.password()));
}

Assim como fizemos no método register, mapeamos UserDto para a classe de entidade de domínio User e
então o passamos para o método login.

4. UserAccessOutputAdapter implementa UserAccessOutputPort:

@ApplicationScoped
public class UserAccessOutputAdapter implements
 UserAccessOutputPort {
 @Inject
 UserRepository userRepository;
 /** Code omitted **/
}

Ao injetar UserRepository, estamos efetivamente transformando esse adaptador de saída em um que
lida com bancos de dados.

5. Precisamos implementar o método findByEmail:

@Override
public Optional<User> findByEmail(String email) {
 return UserMapper
 .userDataToDomain(
 userRepository.findByEmail(email));
}

Usamos UserRepository ao implementar findByEmail da interface UserAccessOutputPort .
UserMapper é uma classe auxiliar para mapear a classe de entidade ORM chamada
UserData para a classe de entidade de domínio User.

6. Por fim, implementamos o método persist:

@Transactional
@Override
public void persist(User user) {
 var userData = UserMapper.userDomainToData(user);
 userRepository.persist(userData);
}

Usamos novamente a classe auxiliar UserMapper para mapear a classe de entidade de domínio User
para a classe de entidade ORM UserData . Isso é necessário porque não podemos persistir a
entidade de domínio. Então, passamos a classe de entidade ORM UserData para o método persist do UserRepository.

A introdução do Framework hexagon permite que os clientes acessem a API do sistema fornecida
por adaptadores de entrada e conectem o aplicativo hexagonal a uma fonte de dados externa, um
banco de dados em nosso caso. O adaptador de entrada do Framework hexagon não difere muito
quando comparado aos endpoints REST fornecidos pela camada de API. Ambas as abordagens
expõem métodos semelhantes, dependem de classes DTO para mapear solicitações de clientes
e enviá-las para a camada de serviço ou para o Application hexagon.

O que muda significativamente é como os dados externos são manipulados. Na abordagem
hexagonal, o adaptador de saída implementa uma porta de saída, que fornece flexibilidade com
a abstração da porta de saída. Um novo adaptador de saída pode ser implementado sem
interromper a lógica do sistema central . Por outro lado, não há tal abstração na abordagem de
arquitetura em camadas. A camada de serviço depende diretamente das classes de repositório da camada de dados.

Vamos ver agora como podemos testar a aplicação hexagonal.

========================================
Testando a aplicação hexagonal

Como a lógica do sistema central é parte do hexágono Domain, podemos criar testes unitários para
validar os comportamentos da entidade de domínio User . A seguir está a aparência de um desses testes unitários:

@QuarkusTest
public class UserServiceTest {
@Test
public void givenTheUserEmailAlreadyExistsAnException
 IsThrown() {
 var user = new User("test@davivieira.dev", "password");
 var optionalUser = Optional.of(user);
 Assertions.assertThrows(
 Exception.class,
 ()-> user.isEmailAlreadyUsed(optionalUser)
 );
}
/** Code omitted **/
}

Na abordagem em camadas, tivemos que injetar uma classe de serviço e fornecer um banco de dados
para testar se o e-mail já estava sendo usado. Na abordagem hexagonal, estamos testando a lógica diretamente do Usuário
classe de entidade de domínio. Mover a lógica do sistema central da camada de serviço, na arquitetura
em camadas, para o hexágono de domínio na arquitetura hexagonal forneceu a flexibilidade para
executar testes mais restritos sem dependências de recursos externos.

Com base em nossa implementação do mesmo aplicativo usando arquitetura em camadas e hexagonal,
vamos avaliar os prós e contras de cada arquitetura.

